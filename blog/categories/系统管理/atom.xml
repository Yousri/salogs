<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 系统管理 | Salogs]]></title>
  <link href="http://yousri.github.com/salogs/blog/categories/系统管理/atom.xml" rel="self"/>
  <link href="http://yousri.github.com/salogs/"/>
  <updated>2011-12-23T16:21:58+08:00</updated>
  <id>http://yousri.github.com/salogs/</id>
  <author>
    <name><![CDATA[Yousri]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Linux常用性能监控分析工具]]></title>
    <link href="http://yousri.github.com/salogs/blog/performance-monitoring-and-analysis-tools/"/>
    <updated>2011-12-19T21:54:00+08:00</updated>
    <id>http://yousri.github.com/salogs/blog/performance-monitoring-and-analysis-tools</id>
    <content type="html"><![CDATA[<h2>一、系统级别性能分析工具</h2>

<p>这里主要是包括CPU、内存、磁盘I/O以及网络带宽常用的检测分析工具，如：</p>

<ul>
<li>借助vmstat、sar、iostat检测是否是CPU瓶颈;</li>
<li>借助free、vmstat检测是否是内存瓶颈;</li>
<li>借助iostat检测是否是磁盘I/O瓶颈;</li>
<li>借助netstat检测是否是网络带宽瓶颈;</li>
</ul>


<!-- more -->


<h2>top</h2>

<p>显示所有正在运行进程的详细信息及关于系统各方面如内存、CPU、负载等状态情况. <br/>
个人较常用到参数是：显示多cpu各个信息--按1键;  进程详细路径--按字母c键</p>

<h2>ps</h2>

<h2>pstree</h2>

<p>以树状图显示运行的程序，可以指定程序识别码或用户名称对应的运行程序关系：pstree option  [程序识别码/用户名称] 其参数如下：</p>

<pre><code>-a 　显示每个程序的完整指令，包含路径，参数或是常驻服务的标示。   
-c 　不使用精简标示法。   
-G 　使用VT100终端机的列绘图字符。   
-h 　列出树状图时，特别标明现在执行的程序。   
-H   此参数的效果和指定”-h”参数类似，但特别标明指定的程序。   
-l 　采用长列格式显示树状图。   
-n 　用程序识别码排序。预设是以程序名称来排序。   
-p 　显示程序识别码。   
-u 　显示用户名称。   
-U 　使用UTF-8列绘图字符。    
-V 　显示版本信息。   
</code></pre>

<h2>free</h2>

<p>free是监控linux内存使用状况最常用简单的指令：</p>

<pre><code>[yousri@jmxc ~]$ free
            total       used       free     shared    buffers     cached
Mem:      12293188   11201156    1092032          0     459200    2451612
-/+ buffers/cache:    8290344    4002844
Swap:      8193108     720552    7472556
</code></pre>

<p>程序应用实际使用的内存是：-buffers/cache 即userd-buffers-cached = 8290344 <br/>
剩余可用内存是：+buffers/cache 即free+buffers+cached = 4002844</p>

<p>对此两点解释说明：</p>

<pre><code>对操作系统来讲是Mem的参数.buffers/cached 都是属于被使用,所以它认为free只有1092032.
对应用程序来讲是(-/+ buffers/cach).buffers/cached 是等同可用的，因为buffer/cached是为了提高程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。
</code></pre>

<h2>Vmstat</h2>

<p>[yousri@jmxc ~]$vmstat 5 5</p>

<p>  Procs：运行及等待中的进程数</p>

<pre><code>-r:运行的和等待(CPU时间片)运行的进程数，这个值也可以判断是否需要增加CPU(长期大于1)
-b:处于不可中断状态的进程数，常见的情况是由IO引起的
</code></pre>

<p>  Memory：内存使用比例包括交换内存、读写缓存及应用程序的cache情况。</p>

<pre><code>-swpd: 切换到交换内存上的内存(默认以KB为单位)
如果 swpd 的值不为0，或者还比较大，比如超过100M了，但是 si, so 的值长期为 0，这种情况我们可以不用担心，不会影响系统性能。
-free: 空闲的物理内存
-buff: 作为buffer cache的内存，对块设备的读写进行缓冲
-cache: 作为page cache的内存, 文件系统的cache
如果 cache 的值大的时候，说明cache住的文件数多，如果频繁访问到的文件都能被cache住，那么磁盘的读IO bi 会非常小。
</code></pre>

<p>  Swap：交换内存使用情况</p>

<pre><code>-si: 交换内存使用，由磁盘调入内存 
-so: 交换内存使用，由内存调入磁盘
内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响。磁盘IO和CPU资源都会被消耗。
</code></pre>

<p>我发现有些朋友看到空闲内存(free)很少或接近于0时，就认为内存不够用了，实际上不能光看这一点的，还要结合si,so，如果free很少，但是si,so也很少(大多时候是0)，那么不用担心，系统性能这时不会受到影响的。</p>

<p>  I/O：磁盘读写数据负载情况</p>

<pre><code>-bi: 从块设备读入的数据总量(读磁盘) (KB/s)，
-bo: 写入到块设备的数据总理(写磁盘) (KB/s)
</code></pre>

<p>随机磁盘读写的时候，这2个 值越大（如超出1M），能看到CPU在IO等待的值也会越大</p>

<p>  System：系统读写上下午切换次数情况</p>

<pre><code>-in: 每秒产生的中断次数
-cs: 每秒产生的上下文切换次数
</code></pre>

<p>上面这2个值越大，会看到由内核消耗的CPU时间会越多</p>

<p>  CPU：CPU使用情况：包括用户应用、系统本身以及I/O读写等待消耗的各个CPU消耗比例。</p>

<pre><code>-us: 用户进程消耗的CPU时间百分比
us 的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超过50% 的使用，那么我们就该考虑优化程序算法或者进行加速了(比如 PHP/Perl)
-sy: 内核进程消耗的CPU时间百分比
sy 的值高时，说明系统内核消耗的CPU资源多，这并不是良性的表现，我们应该检查原因。
-wa: IO等待消耗的CPU时间百分比
wa 的值高时，说明IO等待比较严重，这可能是由于磁盘大量作随机访问造成，也有可能是磁盘的带宽出现瓶颈(块操作)。
-id: CPU处在空闲状态时间百分比   
</code></pre>

<p>  情景分析：这个vmstat的输出那些信息值得关注？</p>

<pre><code>-Procs r: 运行的进程比较多，系统很繁忙
-Io bo: 磁盘写的数据量稍大，如果是大文件的写，10M以内基本不用担心，如果是小文件写2M以内基本正常
Cpu us: 持续大于50，服务高峰期可以接受
Cpu wa: 稍微有些高
Cpu id:持续小于50，服务高峰期可以接受
</code></pre>

<h2>iostat</h2>

<p>[yousri@jmxc ~]$iostat -x 5</p>

<pre><code>rrqm/s: 每秒进行 merge 的读操作数目。即 delta(rmerge)/s
wrqm/s: 每秒进行 merge 的写操作数目。即 delta(wmerge)/s
r/s:    每秒完成的读 I/O 设备次数。即 delta(rio)/s
w/s:    每秒完成的写 I/O 设备次数。即 delta(wio)/s
rsec/s: 每秒读扇区数。即 delta(rsect)/s
wsec/s: 每秒写扇区数。即 delta(wsect)/s
rkB/s:  每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算)
wkB/s:  每秒写K字节数。是 wsect/s 的一半。(需要计算)
avgrq-sz:   平均每次设备I/O操作的数据大小 (扇区)。delta(rsect+wsect)/delta(rio+wio)
avgqu-sz:   平均I/O队列长度。即 delta(aveq)/s/1000 (因为aveq的单位为毫秒)。
await:      平均每次设备I/O操作的等待时间 (毫秒)。即 delta(ruse+wuse)/delta(rio+wio)
svctm:      平均每次设备I/O操作的服务时间 (毫秒)。即 delta(use)/delta(rio+wio)
%util:      一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。即 delta(use)/s/1000 (因为use的单位为毫秒)
</code></pre>

<p>相关分析:</p>

<pre><code>如果 %util 接近 100%，基本是产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。
idle小于70% IO压力就较大了,一般读取速度有较多的wait。
同时可以结合vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比,高过30%时IO压力高) 
另外 await 的参数也要多和 svctm 来参考。差的过高就一定有 IO 的问题。 
avgqu-sz 也是个做 IO 调优时需要注意的地方，这个就是直接每次操作的数据的大小，如果次数多，但数据拿的小的话，其实 IO 也会很小.如果数据拿的大，才IO 的数据会高。
也可以通过 avgqu-sz × ( r/s or w/s ) = rsec/s or wsec/s.也就是讲，读定速度是这个来决定的。    
并发请求的数量：并发= (r/s+w/s)*(svctm/1000)
</code></pre>

<h2>dstat</h2>

<h2>mpstat</h2>

<p>mpstat命令可用于监测一个多CPU系统中每个可用CPU的情况，同时也可以像vmstat命令那样使用参数进行一定频率的采样结果的监测。</p>

<h2>pmap</h2>

<p>pmap命令可以显示进程的内存映射，可以用于找出造成内存瓶颈的原因：pmap -d pid</p>

<h2>sar</h2>

<p>sar可视为是iostat及vmstat为一体的工具，其命令行常用格式:sar [options] [-A] [-o file] t n 注：n和t分别代表采样次数及时间间隔;-o file表示将命令行输出结果以二进制保存在文件中;options为命令行选项，常用包括有：</p>

<pre><code>-A：所有报告的总和;
-u：CPU利用率;
-v：进程、I节点、文件和锁表状态;
-d：硬盘使用报告;
-r：没有使用的内存页面和硬盘块;
-g：串口I/O的情况;
-b：缓冲区使用情况;
-a：文件读写情况;
-c：系统调用情况;
-R：进程的活动情况;
-y：终端设备活动情况;
-w：系统交换活动;
</code></pre>

<h2>uptime</h2>

<p>uptime 快捷的查看服务器运行时间、在线用户数、系统即时、每五/十五分钟的平均负载情况：</p>

<pre><code>[yousri@jmxc ~]$ uptime
 10:35:27 up 242 days, 17:07,  1 user,  load average: 0.13, 0.07, 0.01
</code></pre>

<h2>strace</h2>

<p>Strace：用于跟踪进程执行时的系统调用和所接收的信号。 <br/>
在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。
使用参数：</p>

<pre><code>-p  跟踪指定的进程
-f  跟踪由fork子进程系统调用
-F  尝试跟踪vfork子进程系统调吸入，与-f同时出现时, vfork不被跟踪
-o filename 默认strace将结果输出到stdout。通过-o可以将输出写入到filename文件中
-ff 常与-o选项一起使用，不同进程(子进程)产生的系统调用输出到filename.PID文件
-r  打印每一个系统调用的相对时间
-t  在输出中的每一行前加上时间信息。 -tt 时间确定到微秒级。还可以使用-ttt打印相对时间
-v  输出所有系统调用。默认情况下，一些频繁调用的系统调用不会输出
-s  指定每一行输出字符串的长度,默认是32。文件名一直全部输出
-c  统计每种系统调用所执行的时间，调用次数，出错次数。
-e  expr     输出过滤器，通过表达式，可以过滤出掉你不想要输出
</code></pre>

<h2>lsof</h2>

<h2>二、网络分析定位命令工具</h2>

<h2>ping</h2>

<h2>traceroute</h2>

<h2>netstat</h2>

<p>服务连接状态：netstat -nat|awk '{print $6}|sort|uniq -c|sort -rn</p>

<h2>mtr</h2>

<p>最初通常只是使用ping判断网络丢包情况，再结合traceroute跟踪路由走向，直到后来才发现原来linux下有个更好的具备这两者功能的网络分析判断工具，可以说是结合了ping/nslookup/traceroute为一体来判断网络的相关特性，它即是mtr。最常用到的参数为：</p>

<pre><code>mtr -n -r -c 15 ip
-n no-dns 不对ip地址做域名解析
-r 已报告模式显示
-c 设置每秒发送数据包数量
</code></pre>

<p>结果总共包括八列数据分别是：</p>

<pre><code>第一列：ip或域名;
第二列：设置每秒发送数据包的数量;
第三列：显示每个对应ip的丢包率;
第四列：显示最近一次的返回时延;
第五列：发送ping包的平均时延;
第六列：时延最短的时间;
第七列：时延最长的时间;
第八列：标准偏差;
</code></pre>

<h2>NC</h2>

<p>nc全程<code>NetCat</code> 号称是网络工具中的“瑞士军刀” <br/>
通用方法: <br/>
想要连接到某处: nc [-options] hostname port[s] [ports] … <br/>
绑定端口等待连接: nc -l -p port [-options] [hostname] [port] <br/>
参数:</p>

<pre><code>-g gateway source-routing hop point[s], up to 8
-G num source-routing pointer: 4, 8, 12, …
-h 帮助信息
-i secs 延时的间隔
-l 监听模式，用于入站连接
-n 指定数字的IP地址，不能用hostname
-o file 记录16进制的传输
-p port 本地端口号
-r 任意指定本地及远程端口
-s addr 本地源地址
-u UDP模式
-v 详细输出——用两个-v可得到更详细的内容
-w secs timeout的时间
-z 将输入输出关掉——用于扫描时，其中端口号可以指定一个或者用lo-hi式的指定范围。
</code></pre>

<p>常用用途：远程拷贝数据、端口扫描 如：</p>

<pre><code>nc -v -w 2 ip -z 21-1024   #端口扫描
nc -l 8888 &gt; tmp.log #ip:192.168.1.100上执行
nc 192.168.1.100 8888 &lt; tmp.log #拷贝
</code></pre>

<h2>nmap</h2>

<p>http://xukaizijian.blog.163.com/blog/static/1704331192011011101745336/</p>

<h2>三、Mysql性能瓶颈分析定位工具命令</h2>

<h2>show full processlist</h2>

<h2>show slow puery</h2>

<h2>Explain</h2>

<p>Explain Select .... <br/>
执行后包含的信息:ID、Select_type、Table、Type、Possible_keys、Key、Key_len、Ref、Rows、Extra <br/>
Select_type：表示查询每个select子句的类型（简单或复杂）</p>

<pre><code>SIMPLE:查询中不包含子查询或union;
PRIMARY:查询中若包含任何复杂的子部分;
SUBQUERY:在select或where列表中包含子查询;
DERIVED:在from列表中包含子查询;
UNION
UNION RESULT
</code></pre>

<p>Type: 表示Mysql在表中找到所需行的方式，又称“访问类型”，常见类型由差到优依次如下：ALL  index  range  ref  eq_ref  const,system  NULL</p>

<pre><code>ALL:Full Table Scan   Mysql需遍历全表找到匹配的行;
index:Full index Scan index与all的区别在于其只遍历索引查询（使用到索引）;
range: 索引范围扫描，对索引的扫描开始于某一点，返回匹配值域的行，常见于between/&lt;/&gt;等的查询;
ref: 非唯一索引扫描，返回匹配某个单独值的所有行。常见于使用非唯一索引即唯一索引的非唯一前缀进行的查找;
eq_ref: 唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描;
const,system: 当mysql对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中。
NULL: Mysql在优化过程中分解语句，执行时甚至不用访问表或索引;
</code></pre>

<p>Possible_keys：指出Mysql能使用哪个索引在表中找到行，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用 <br/>
Key：显示Mysql在查询中实际使用的索引，若没有使用索引，显示为NULL <br/>
Key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度 <br/>
Ref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值 <br/>
Rows：表示Mysql根据表统计信息及索引选用情况估算的找到所需的记录所需要读取的行数 <br/>
Extra：包含不适合在其他列中显示但十分重要的额外信息</p>

<pre><code>Using index 表示相应的select操作中使用了覆盖索引
Using Where 
Using temporary 表示Mysql需要使用临时表来存储结果集，常见于排序或分组查询
Using filesort 表示Mysql中无法利用索引完成的排序操作即“文件排序”
</code></pre>

<h2>Set Profiles</h2>

<p>Mysql的Query Profiler 是一个使用方便的Query诊断分析工具，可以获取一条Query在整个执行过程中多种资源的消耗情况，如：CPU、IO、SWAP等，同时还能得到该Query执行过程Mysql所调用的各个函数在源文件中的文件。用法如下： <br/>
此是用户变量，需要时需每次开启profiles功能</p>

<pre><code>mysql&gt; set profiling=1;
mysql&gt; show profiles;
mysql&gt; show profile for query 2;
mysql&gt; show profile cpu for query 2;
或
mysql&gt; show profile cpu,block io,memory,swaps for query 2;
</code></pre>

<h2>mysqlreport</h2>
]]></content>
  </entry>
  
</feed>
